---
// TerminalEmbed — full-viewport xterm.js terminal connected to WASM TUI
---

<div class="terminal-fullscreen" aria-label="Interactive Terminal">
  <div id="terminal-embed" class="terminal-viewport"></div>
  <div id="terminal-loading" class="terminal-overlay">
    <span class="loading-text">Loading terminal&hellip;</span>
  </div>
  <div id="terminal-error" class="terminal-overlay" hidden>
    Terminal failed to load.
    <a href="javascript:location.reload()">Retry</a>
  </div>
</div>

<script>
  import { Terminal } from '@xterm/xterm'
  import { FitAddon } from '@xterm/addon-fit'

  interface WasmWindow extends Window {
    terminalPortfolioWrite: (data: string | Uint8Array) => void
    terminalPortfolioInput?: (data: string) => void
    terminalPortfolioResize?: (cols: number, rows: number) => void
    onWasmReady: () => void
    Go: new () => {
      importObject: WebAssembly.Imports
      run: (instance: WebAssembly.Instance) => void
    }
  }

  const w = window as unknown as WasmWindow

  async function initTerminal() {
    const container = document.getElementById('terminal-embed')
    const loadingEl = document.getElementById('terminal-loading')
    const errorEl = document.getElementById('terminal-error')
    if (!container || !loadingEl || !errorEl) return

    // Skip if already initialized
    if (container.dataset.initialized === 'true') return
    container.dataset.initialized = 'true'

    // Wait for JetBrains Mono to load before creating the terminal.
    // xterm.js builds a glyph atlas on init — if the font isn't ready,
    // box-drawing characters render with the wrong fallback font.
    try {
      await document.fonts.load("14px 'JetBrains Mono'")
    } catch {
      // Font API may not be available; proceed anyway
    }

    const isDark = document.documentElement.getAttribute('data-theme') !== 'light'
    const bg = isDark ? '#0d0d0d' : '#f5f2ed'
    const fg = isDark ? '#c8c0b8' : '#1a1a1a'

    const term = new Terminal({
      cursorBlink: true,
      fontSize: 14,
      fontFamily: "'JetBrains Mono', monospace",
      theme: { background: bg, foreground: fg, cursor: fg },
      rows: 24,
      cols: 80,
      scrollback: 0,
      customGlyphs: true,
      allowProposedApi: true,
    })

    const fitAddon = new FitAddon()
    term.loadAddon(fitAddon)
    term.open(container)

    // Initial fit
    try {
      fitAddon.fit()
    } catch {
      // fit can fail if element isn't visible yet
    }

    // Resize handling — fill viewport on any size change
    const resizeObserver = new ResizeObserver(() => {
      try {
        fitAddon.fit()
      } catch {
        // ignore
      }
    })
    resizeObserver.observe(container)

    // Wire output from WASM → xterm (receives Uint8Array of raw UTF-8 bytes)
    w.terminalPortfolioWrite = (data: string | Uint8Array) => {
      term.write(data)
    }

    // Called when WASM Go runtime is ready
    w.onWasmReady = () => {
      loadingEl.hidden = true
      // Send initial size
      const terminalResize = w.terminalPortfolioResize
      if (terminalResize) {
        terminalResize(term.cols, term.rows)
      }
    }

    // Wire keyboard input from xterm → WASM
    term.onData((data: string) => {
      const terminalInput = w.terminalPortfolioInput
      if (terminalInput) {
        terminalInput(data)
      }
    })

    // Wire resize from xterm → WASM
    term.onResize(({ cols, rows }: { cols: number; rows: number }) => {
      const terminalResize = w.terminalPortfolioResize
      if (terminalResize) {
        terminalResize(cols, rows)
      }
    })

    // Load WASM
    loadWasm(loadingEl, errorEl)
  }

  async function loadWasm(loadingEl: HTMLElement, errorEl: HTMLElement) {
    try {
      // wasm_exec.js sets up the Go class on globalThis
      await loadScript('/wasm_exec.js')

      const go = new w.Go()
      const result = await WebAssembly.instantiateStreaming(
        fetch('/main.wasm'),
        go.importObject,
      )
      go.run(result.instance)
    } catch (err) {
      console.error('WASM load failed:', err)
      loadingEl.hidden = true
      errorEl.hidden = false
    }
  }

  function loadScript(src: string): Promise<void> {
    return new Promise((resolve, reject) => {
      // Don't load twice
      if (document.querySelector(`script[src="${src}"]`)) {
        resolve()
        return
      }
      const s = document.createElement('script')
      s.src = src
      s.onload = () => resolve()
      s.onerror = reject
      document.head.appendChild(s)
    })
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTerminal)
  } else {
    initTerminal()
  }
</script>

<style>
  @import '@xterm/xterm/css/xterm.css';

  .terminal-fullscreen {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .terminal-viewport {
    width: 100%;
    height: 100%;
  }

  .terminal-viewport :global(.xterm) {
    height: 100%;
    padding: 4px;
  }

  /* Hide xterm's own scrollbar — the TUI has its own scroll indicators */
  .terminal-viewport :global(.xterm-viewport) {
    overflow-y: hidden !important;
  }

  .terminal-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg);
    color: var(--muted);
    font-size: 0.9rem;
    z-index: 1;
  }

  .loading-text {
    font-family: 'JetBrains Mono', monospace;
  }

  .terminal-overlay a {
    color: var(--fg);
    margin-left: 0.5rem;
    text-decoration: underline;
  }

  .terminal-overlay[hidden] {
    display: none;
  }
</style>

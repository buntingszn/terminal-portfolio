---
interface Props {
  portrait: string
  class?: string
}

const { portrait, class: className } = Astro.props
---

<div class:list={['portrait-shimmer-wrap', className]} aria-hidden="true">
  <pre class="portrait-fallback">{portrait}</pre>
  <canvas class="portrait-canvas"></canvas>
</div>

<script>
  import fragSource from '../shaders/portrait-shimmer.frag.glsl?raw';

  const vertSource = `#version 300 es
    out vec2 vUV;
    void main() {
      // Fullscreen quad from gl_VertexID (0,1,2,3) — no vertex buffer needed
      vec2 pos = vec2(gl_VertexID & 1, (gl_VertexID >> 1) & 1) * 2.0 - 1.0;
      // UV from clip coords; flip Y for 2D canvas texture (top-down)
      vUV = vec2(pos.x * 0.5 + 0.5, 0.5 - pos.y * 0.5);
      gl_Position = vec4(pos, 0.0, 1.0);
    }
  `;

  interface ShimmerInstance {
    gl: WebGL2RenderingContext;
    raf: number;
    frame: number;
    uTime: WebGLUniformLocation;
    uMuted: WebGLUniformLocation;
    uFg: WebGLUniformLocation;
    canvas: HTMLCanvasElement;
    textTex: WebGLTexture;
    program: WebGLProgram;
    vao: WebGLVertexArrayObject;
    resizeObs: ResizeObserver;
    themeObs: MutationObserver;
  }

  const instances = new Map<HTMLElement, ShimmerInstance>();

  function parseHexColor(hex: string): [number, number, number] {
    hex = hex.trim().replace('#', '');
    if (hex.length === 3) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    return [
      parseInt(hex.slice(0, 2), 16) / 255,
      parseInt(hex.slice(2, 4), 16) / 255,
      parseInt(hex.slice(4, 6), 16) / 255,
    ];
  }

  function getThemeColor(name: string): [number, number, number] {
    const val = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    return parseHexColor(val);
  }

  function createTextTexture(
    gl: WebGL2RenderingContext,
    pre: HTMLPreElement,
    canvas: HTMLCanvasElement,
  ): WebGLTexture | null {
    const dpr = window.devicePixelRatio || 1;
    const rect = pre.getBoundingClientRect();
    const w = Math.round(rect.width * dpr);
    const h = Math.round(rect.height * dpr);
    if (w === 0 || h === 0) return null;

    // Render braille text to an offscreen 2D canvas as white-on-transparent
    const off = new OffscreenCanvas(w, h);
    const ctx = off.getContext('2d')!;
    ctx.scale(dpr, dpr);

    // Match the pre's font styling exactly
    const style = getComputedStyle(pre);
    ctx.font = `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#ffffff';

    const lineHeight = parseFloat(style.lineHeight) || parseFloat(style.fontSize) * 1.2;
    const text = pre.textContent || '';
    const lines = text.split('\n');
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], 0, i * lineHeight);
    }

    // Size the WebGL canvas to match
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    canvas.width = w;
    canvas.height = h;
    gl.viewport(0, 0, w, h);

    // Upload as texture
    const tex = gl.createTexture()!;
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, off);

    return tex;
  }

  function compileShader(gl: WebGL2RenderingContext, type: number, src: string): WebGLShader | null {
    const shader = gl.createShader(type)!;
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  function initShimmer(wrap: HTMLElement) {
    const pre = wrap.querySelector<HTMLPreElement>('.portrait-fallback')!;
    const canvas = wrap.querySelector<HTMLCanvasElement>('.portrait-canvas')!;

    // Respect reduced motion
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

    const gl = canvas.getContext('webgl2', { alpha: true, premultipliedAlpha: false });
    if (!gl) return; // No WebGL2 — fallback stays visible

    // Compile shaders
    const vert = compileShader(gl, gl.VERTEX_SHADER, vertSource);
    const frag = compileShader(gl, gl.FRAGMENT_SHADER, fragSource);
    if (!vert || !frag) return;

    const program = gl.createProgram()!;
    gl.attachShader(program, vert);
    gl.attachShader(program, frag);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(program));
      return;
    }
    gl.useProgram(program);

    // Clean up shader objects
    gl.deleteShader(vert);
    gl.deleteShader(frag);

    // Empty VAO for vertex-ID-based quad
    const vao = gl.createVertexArray()!;
    gl.bindVertexArray(vao);

    // Uniforms
    const uText = gl.getUniformLocation(program, 'uText')!;
    const uTime = gl.getUniformLocation(program, 'uTime')!;
    const uMuted = gl.getUniformLocation(program, 'uMuted')!;
    const uFg = gl.getUniformLocation(program, 'uFg')!;
    const uGrid = gl.getUniformLocation(program, 'uGrid')!;

    gl.uniform1i(uText, 0);

    // Grid: count lines and max columns from portrait text
    const text = pre.textContent || '';
    const lines = text.split('\n').filter((l) => l.length > 0);
    const rows = lines.length;
    const cols = Math.max(...lines.map((l) => [...l].length));
    gl.uniform2f(uGrid, cols, rows);

    // Create text texture
    const textTex = createTextTexture(gl, pre, canvas);
    if (!textTex) return;

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, textTex);

    // Set initial colors
    const muted = getThemeColor('--muted');
    const fg = getThemeColor('--fg');
    gl.uniform3f(uMuted, ...muted);
    gl.uniform3f(uFg, ...fg);

    // Enable blending for alpha
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.clearColor(0, 0, 0, 0);

    // Show canvas, hide fallback
    canvas.style.display = 'block';
    pre.style.visibility = 'hidden';

    let frame = 0;
    let raf = 0;

    function render() {
      gl!.clear(gl!.COLOR_BUFFER_BIT);
      gl!.uniform1f(uTime, frame);
      gl!.drawArrays(gl!.TRIANGLE_STRIP, 0, 4);
      frame++;
      raf = requestAnimationFrame(render);
    }
    raf = requestAnimationFrame(render);

    // Theme observer: watch for data-theme changes on <html>
    const themeObs = new MutationObserver(() => {
      const m = getThemeColor('--muted');
      const f = getThemeColor('--fg');
      gl!.useProgram(program);
      gl!.uniform3f(uMuted, ...m);
      gl!.uniform3f(uFg, ...f);
    });
    themeObs.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['data-theme'],
    });

    // Resize observer: rebuild text texture on size change
    const resizeObs = new ResizeObserver(() => {
      const newTex = createTextTexture(gl!, pre, canvas);
      if (newTex) {
        gl!.deleteTexture(inst.textTex);
        inst.textTex = newTex;
        gl!.activeTexture(gl!.TEXTURE0);
        gl!.bindTexture(gl!.TEXTURE_2D, newTex);
      }
    });
    resizeObs.observe(pre);

    const inst: ShimmerInstance = {
      gl, raf, frame, uTime, uMuted, uFg, canvas, textTex, program, vao,
      resizeObs, themeObs,
    };
    instances.set(wrap, inst);

    // Context lost/restored
    canvas.addEventListener('webglcontextlost', (e) => {
      e.preventDefault();
      cancelAnimationFrame(inst.raf);
      canvas.style.display = 'none';
      pre.style.visibility = 'visible';
    });

    canvas.addEventListener('webglcontextrestored', () => {
      destroyShimmer(wrap);
      initShimmer(wrap);
    });
  }

  function destroyShimmer(wrap: HTMLElement) {
    const inst = instances.get(wrap);
    if (!inst) return;
    cancelAnimationFrame(inst.raf);
    inst.resizeObs.disconnect();
    inst.themeObs.disconnect();
    const { gl } = inst;
    gl.deleteTexture(inst.textTex);
    gl.deleteProgram(inst.program);
    gl.deleteVertexArray(inst.vao);
    const ext = gl.getExtension('WEBGL_lose_context');
    if (ext) ext.loseContext();
    instances.delete(wrap);

    // Restore fallback visibility
    const pre = wrap.querySelector<HTMLPreElement>('.portrait-fallback');
    const canvas = wrap.querySelector<HTMLCanvasElement>('.portrait-canvas');
    if (pre) pre.style.visibility = 'visible';
    if (canvas) canvas.style.display = 'none';
  }

  function initAll() {
    document.querySelectorAll<HTMLElement>('.portrait-shimmer-wrap').forEach((wrap) => {
      if (instances.has(wrap)) return;
      document.fonts.ready.then(() => initShimmer(wrap));
    });
  }

  function destroyAll() {
    instances.forEach((_, wrap) => destroyShimmer(wrap));
  }

  // Astro page lifecycle
  document.addEventListener('astro:page-load', initAll);
  document.addEventListener('astro:before-swap', destroyAll);
</script>

<style>
  .portrait-shimmer-wrap {
    position: relative;
    overflow: hidden;
    flex-shrink: 0;
  }

  .portrait-fallback {
    color: var(--muted);
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    line-height: 1.2;
    background: none;
    padding: 0;
    margin: 0;
    white-space: pre;
    user-select: none;
  }

  .portrait-canvas {
    position: absolute;
    top: 0;
    left: 0;
    display: none;
    pointer-events: none;
  }

  @media (prefers-reduced-motion: reduce) {
    .portrait-canvas {
      display: none !important;
    }
    .portrait-fallback {
      visibility: visible !important;
    }
  }

  @media (max-width: 640px) {
    .portrait-shimmer-wrap {
      display: none;
    }
  }
</style>
